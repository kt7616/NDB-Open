<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>NDB Open Data 簡易解析サイト - 都道府県別 算定回数マップ</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
:root {
  --bg: #f8fafc; --card: #fff; --border: #e2e8f0; --border-lt: #f1f5f9;
  --text: #1e293b; --text-m: #475569; --text-l: #64748b; --text-ll: #94a3b8;
  --pri: #0ea5e9; --pri-h: #0284c7; --pri-lt: #e0f2fe;
  --shadow: 0 1px 3px rgba(0,0,0,.06); --shadow-lg: 0 4px 12px rgba(0,0,0,.07);
  --rad: 10px; --side-w: 320px; --hdr-h: 56px;
}
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
html{font-size:13px}
body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI','Hiragino Sans','Noto Sans JP',sans-serif;background:var(--bg);color:var(--text);line-height:1.5;overflow:hidden;height:100vh}

/* Layout */
#app{display:flex;flex-direction:column;height:100vh}
header{height:var(--hdr-h);background:var(--card);border-bottom:1px solid var(--border);display:flex;align-items:center;padding:0 24px;flex-shrink:0;box-shadow:var(--shadow);z-index:10}
header h1{font-size:19px;font-weight:600} header h1 b{color:#0ea5e9}
header .sub{margin-left:14px;font-size:13px;color:var(--text-ll)}
.content{display:flex;flex:1;overflow:hidden}

/* Theme overrides */
.content.theme-green{--pri:#22c55e;--pri-h:#16a34a;--pri-lt:#dcfce7}
.content.theme-orange{--pri:#f97316;--pri-h:#ea580c;--pri-lt:#ffedd5}

/* Sidebar */
.sidebar{width:var(--side-w);flex-shrink:0;background:var(--card);border-right:none;overflow-y:auto;padding:12px;display:flex;flex-direction:column;gap:10px;transition:width .25s ease,padding .25s ease,opacity .2s ease}
.sidebar.collapsed{width:0 !important;min-width:0;padding:0;overflow:hidden;opacity:0}
.sidebar-toggle{width:34px;height:34px;border:1px solid var(--border);border-radius:7px;background:var(--card);cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:18px;color:var(--text-l);transition:all .15s;margin-right:12px;flex-shrink:0;line-height:1}
.sidebar-toggle:hover{background:var(--border-lt);color:var(--text-m);border-color:var(--border)}
.sidebar-toggle.active{color:var(--pri);border-color:var(--pri);background:var(--pri-lt)}

/* Tab bar */
.tab-bar{display:flex;gap:0;background:var(--bg);border-radius:var(--rad);padding:3px;border:1px solid var(--border)}
.tab-btn{flex:1;padding:7px 4px;border:none;border-radius:7px;background:transparent;color:var(--text-l);font-size:12px;font-weight:600;cursor:pointer;transition:all .15s;white-space:nowrap}
.tab-btn:hover{background:var(--card)}
.tab-btn.active{background:var(--card);box-shadow:var(--shadow)}
.tab-btn[data-tab="0"].active{color:#0284c7}
.tab-btn[data-tab="1"].active{color:#16a34a}
.tab-btn[data-tab="2"].active{color:#ea580c}

/* Resize handle */
.resize-handle{width:6px;cursor:col-resize;flex-shrink:0;position:relative;z-index:5;background:transparent;transition:background .15s;border-left:1px solid var(--border)}
.resize-handle:hover,.resize-handle.dragging{background:var(--pri-lt)}
.resize-handle::after{content:'';position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:2px;height:28px;background:var(--border);border-radius:1px}
.panel{background:var(--bg);border:1px solid var(--border-lt);border-radius:var(--rad);padding:12px}
.panel h3{font-size:12px;font-weight:600;text-transform:uppercase;letter-spacing:.04em;color:var(--text-l);margin-bottom:8px}

/* Hierarchical checkboxes */
.code-actions{display:flex;gap:5px;margin-bottom:6px}
.code-actions button{font-size:11px;padding:2px 7px;border:1px solid var(--border);border-radius:4px;background:var(--card);color:var(--text-l);cursor:pointer}
.code-actions button:hover{background:var(--pri-lt);color:var(--pri);border-color:var(--pri)}
.proc-list{max-height:50vh;overflow:auto}
.class-group{margin-bottom:2px}
.class-header{display:flex;align-items:center;gap:6px;padding:5px 4px;cursor:pointer;border-radius:5px;transition:background .1s}
.class-header:hover{background:var(--border-lt)}
.class-toggle{width:14px;font-size:11px;color:var(--text-ll);text-align:center;flex-shrink:0;user-select:none}
.class-header input[type="checkbox"]{width:15px;height:15px;accent-color:var(--pri);cursor:pointer;flex-shrink:0}
.class-code{font-size:12px;font-weight:700;color:var(--pri);min-width:48px}
.class-name{font-size:12.5px;color:var(--text-m);white-space:nowrap}
.class-children{display:none;padding-left:22px}
.class-children.open{display:block}
.proc-item{display:flex;align-items:center;gap:5px;padding:3px 4px;cursor:pointer;border-radius:4px}
.proc-item:hover{background:var(--border-lt)}
.proc-item input[type="checkbox"]{width:13px;height:13px;accent-color:var(--pri);cursor:pointer;flex-shrink:0}
.proc-name{font-size:12px;color:var(--text-m);white-space:nowrap;flex:1}
.proc-pts{font-size:11px;color:var(--text-ll);white-space:nowrap}

/* Year */
.year-disp{text-align:center;font-size:26px;font-weight:700;color:var(--text);margin-bottom:6px}
.year-disp span{font-size:12px;font-weight:400;color:var(--text-ll)}
input[type="range"]{-webkit-appearance:none;appearance:none;width:100%;height:5px;background:var(--border);border-radius:3px;outline:none;cursor:pointer}
input[type="range"]::-webkit-slider-thumb{-webkit-appearance:none;width:18px;height:18px;background:var(--pri);border-radius:50%;cursor:pointer;border:2px solid var(--card);box-shadow:0 1px 3px rgba(0,0,0,.2)}
.year-ticks{display:flex;justify-content:space-between;margin-top:3px;font-size:9px;color:var(--text-ll)}
.play-row{display:flex;align-items:center;gap:6px;margin-top:8px}
.play-btn{flex:1;padding:6px 0;border:1px solid var(--pri);border-radius:6px;background:var(--pri-lt);color:var(--pri);font-size:12px;font-weight:600;cursor:pointer;transition:all .15s}
.play-btn:hover,.play-btn.active{background:var(--pri);color:#fff}
.speed-sel{padding:6px 5px;border:1px solid var(--border);border-radius:6px;font-size:11px;color:var(--text-m);background:var(--card);cursor:pointer}

/* Map stats overlay */
.map-stats{position:absolute;top:10px;left:10px;background:rgba(255,255,255,.93);backdrop-filter:blur(8px);border:1px solid var(--border);border-radius:var(--rad);padding:12px 16px;box-shadow:var(--shadow);z-index:5;pointer-events:none;font-variant-numeric:tabular-nums}
.ms-title{font-size:13px;font-weight:700;color:var(--text);margin-bottom:8px}
.ms-row{display:flex;gap:22px;align-items:flex-start}
.ms-row-spread{display:flex;justify-content:space-between;gap:28px}
.ms-cell{min-width:0}
.ms-lbl{font-size:10px;color:var(--text-ll);white-space:nowrap}
.ms-val{font-size:16px;font-weight:700;color:var(--text);white-space:nowrap;line-height:1.3}
.ms-val-lg{font-size:20px}
.ms-unit{font-size:10.5px;font-weight:400;color:var(--text-ll);margin-left:2px}
.ms-sub{font-size:9.5px;color:var(--text-ll);white-space:nowrap}
.ms-div{border-top:1px solid var(--border-lt);margin:6px 0}

/* Legend hover controls */
.legend-ctrl{position:absolute;bottom:74px;left:50%;transform:translateX(-50%);background:rgba(255,255,255,.95);backdrop-filter:blur(8px);border:1px solid var(--border);border-radius:8px;padding:10px 14px;box-shadow:var(--shadow);z-index:6;opacity:0;pointer-events:none;transition:opacity .15s}
.legend-ctrl.visible{opacity:1;pointer-events:auto}
.lc-row{display:flex;align-items:center;gap:8px;flex-wrap:nowrap}
.lc-lbl{font-size:14px;color:var(--text-ll)}
.lc-input{width:72px;padding:4px 6px;border:1px solid var(--border);border-radius:4px;font-size:15px;text-align:right;color:var(--text);background:var(--card)}
.lc-input:focus{outline:none;border-color:var(--pri)}
.lc-sep{color:var(--text-ll);font-size:15px}
.lc-btn{font-size:14px;padding:4px 10px;border:1px solid var(--border);border-radius:4px;background:var(--card);color:var(--text-l);cursor:pointer;white-space:nowrap}
.lc-btn:hover{background:var(--pri-lt);color:var(--pri);border-color:var(--pri)}
.lc-badge{font-size:13px;padding:2px 6px;border-radius:3px}

/* Download */
.dl-row{display:flex;gap:6px}
.dl-btn{flex:1;padding:9px;border:1px solid var(--border);border-radius:8px;background:var(--card);color:var(--text-m);font-size:12px;font-weight:500;cursor:pointer;transition:all .15s}
.dl-btn:hover{background:var(--text);color:#fff;border-color:var(--text)}

/* Map */
.map-area{flex:1;position:relative;overflow-y:auto;display:flex;flex-direction:column;align-items:stretch;padding:12px;gap:8px}
.map-wrap{position:relative;width:100%;flex-shrink:0}
#map-svg{width:100%;height:100%}
.pref-path{stroke:#fff;stroke-width:.6;transition:fill .3s,stroke .1s,stroke-width .1s}
.pref-path.hovered{stroke:var(--text);stroke-width:1.8;paint-order:fill}
.inset-box{fill:var(--card);stroke:var(--border);stroke-width:1;rx:6}
.inset-label{font-size:10px;fill:var(--text-ll);text-anchor:middle}
.legend-title{font-size:15px;fill:var(--text-l)}
.legend-axis text{font-size:14px;fill:var(--text-ll)}
.legend-axis line,.legend-axis path{stroke:var(--text-ll);stroke-width:.5}

/* Tooltip */
.tooltip{position:absolute;pointer-events:none;background:rgba(255,255,255,.97);backdrop-filter:blur(8px);border:1px solid var(--border);border-radius:10px;padding:12px 16px;box-shadow:var(--shadow-lg);opacity:0;transition:opacity .12s;z-index:100;min-width:180px;max-width:340px}
.tooltip.visible{opacity:1}
.tt-pref{font-size:14px;font-weight:700;margin-bottom:5px}
.tt-row{display:flex;justify-content:space-between;align-items:baseline;font-size:11.5px;padding:1.5px 0;gap:10px}
.tt-lbl{color:var(--text-l);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:200px}
.tt-val{font-weight:600;color:var(--text);text-align:right;white-space:nowrap}
.tt-div{border-top:1px solid var(--border-lt);margin:4px 0}
.tt-hi{font-weight:700;color:var(--pri)}
.empty-st{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none}
.empty-st-text{font-size:13px;color:var(--text-ll);background:var(--card);padding:10px 18px;border-radius:8px;border:1px dashed var(--border)}

/* Loading */
.loading{position:fixed;inset:0;background:var(--bg);display:flex;align-items:center;justify-content:center;z-index:1000;transition:opacity .3s}
.loading.hidden{opacity:0;pointer-events:none}
.spinner{width:32px;height:32px;border:3px solid var(--border);border-top-color:var(--pri);border-radius:50%;animation:spin .7s linear infinite}
@keyframes spin{to{transform:rotate(360deg)}}
.load-text{margin-top:10px;color:var(--text-ll);font-size:12px;text-align:center}

/* Scroll mode: stats flows above map when viewport is narrow */
.map-wrap.scroll-mode{display:flex;flex-direction:column;align-items:stretch;justify-content:flex-start}
.map-wrap.scroll-mode .map-stats{position:relative;top:auto !important;left:auto !important;order:-1;align-self:flex-start;margin-bottom:8px}
.map-wrap.scroll-mode #map-svg{flex-shrink:0}

/* Comparison info panel */
.ci-section{padding:8px 10px;border-radius:6px;margin-bottom:6px;border:1px solid var(--border-lt)}
.ci-section.ci-blue{background:#f0f9ff;border-color:#bae6fd}
.ci-section.ci-green{background:#f0fdf4;border-color:#bbf7d0}
.ci-label{font-size:12px;font-weight:700;margin-bottom:2px}
.ci-blue .ci-label{color:#0284c7}
.ci-green .ci-label{color:#16a34a}
.ci-count{font-size:11px;color:var(--text-l)}
.ci-groups{font-size:10.5px;color:var(--text-ll);margin-top:2px;line-height:1.4}

/* Chart */
.chart-container{flex-shrink:0;width:100%;padding:8px 0}
.chart-container .chart-card{background:var(--card);border:1px solid var(--border);border-radius:var(--rad);padding:14px;position:relative}
.chart-container .chart-title{font-size:12px;font-weight:600;color:var(--text-l);text-transform:uppercase;letter-spacing:.04em;margin-bottom:8px}
#chart-svg{width:100%;display:block}
.chart-legend{display:flex;flex-wrap:wrap;gap:6px 14px;margin-bottom:6px;justify-content:center}
.chart-legend-item{display:flex;align-items:center;gap:4px;font-size:10.5px;color:var(--text-l)}
.chart-legend-line{width:20px;height:2px;border-radius:1px}
.chart-legend-line.dashed{background:repeating-linear-gradient(90deg,currentColor 0 5px,transparent 5px 8px);height:2px}
.chart-tooltip{position:absolute;pointer-events:none;background:rgba(255,255,255,.97);backdrop-filter:blur(8px);border:1px solid var(--border);border-radius:8px;padding:10px 14px;box-shadow:var(--shadow-lg);opacity:0;transition:opacity .12s;z-index:100;min-width:200px;white-space:nowrap}
.chart-tooltip.visible{opacity:1}
.ct-year{font-size:13px;font-weight:700;margin-bottom:6px}
.ct-row{display:flex;align-items:center;gap:8px;font-size:11.5px;padding:1.5px 0}
.ct-dot{width:8px;height:8px;border-radius:50%;flex-shrink:0}
.ct-lbl{color:var(--text-l);flex:1}
.ct-val{font-weight:600;color:var(--text);text-align:right}

</style>
</head>
<body>

<div class="loading" id="loading"><div><div class="spinner"></div><div class="load-text">データを読み込み中...</div></div></div>

<div id="app">
  <header>
    <button class="sidebar-toggle active" id="sidebarToggle" onclick="toggleSidebar()" title="サイドバー切替">&#9776;</button>
    <h1><b>NDB</b> Open Data <span style="font-size:14px;font-weight:400;color:var(--text-l)">簡易解析サイト</span></h1>
    <div class="sub">v1.10 | 最終更新: 2026/02/14</div>
  </header>
  <div class="content" id="contentEl">
    <aside class="sidebar">
      <div class="tab-bar">
        <button class="tab-btn active" data-tab="0" onclick="switchTab(0)">解析1</button>
        <button class="tab-btn" data-tab="1" onclick="switchTab(1)">解析2</button>
        <button class="tab-btn" data-tab="2" onclick="switchTab(2)">比較結果</button>
      </div>
      <div class="panel" id="procPanel">
        <h3>算定項目</h3>
        <div class="code-actions">
          <button onclick="toggleAll(true)">すべて選択</button>
          <button onclick="toggleAll(false)">すべて解除</button>
          <button onclick="expandAll(true)">展開</button>
          <button onclick="expandAll(false)">折畳</button>
        </div>
        <div class="proc-list" id="procList"></div>
      </div>
      <div class="panel" id="compPanel" style="display:none">
        <h3>比較設定</h3>
        <div id="compInfo"></div>
      </div>
      <div class="panel">
        <h3>年度</h3>
        <div class="year-disp" id="yearDisp">2023<span>年度</span></div>
        <input type="range" id="yearSlider" min="2014" max="2023" value="2023" step="1">
        <div class="year-ticks" id="yearTicks"></div>
        <div class="play-row">
          <button class="play-btn" id="playBtn" onclick="toggleAnim()">&#9654; 再生</button>
          <select class="speed-sel" id="speedSel"><option value="1200">ゆっくり</option><option value="600" selected>通常</option><option value="300">速い</option></select>
        </div>
      </div>
      <div class="panel">
        <h3>データ出力</h3>
        <div class="dl-row">
          <button class="dl-btn" onclick="downloadCSV(false)">単年度 CSV</button>
          <button class="dl-btn" onclick="downloadCSV(true)">全年度 CSV</button>
        </div>
      </div>
      <div style="font-size:10px;color:var(--text-ll);line-height:1.5;padding:0 4px">
        データ: 厚生労働省 NDB Open Data / 総務省人口推計<br>地図: 国土交通省 国土数値情報(N03)
      </div>
    </aside>
    <div class="resize-handle" id="resizeHandle"></div>
    <main class="map-area">
      <div class="map-wrap" id="mapWrap">
        <svg id="map-svg"></svg>
        <div class="map-stats" id="mapStats" style="display:none">
          <div class="ms-title" id="sTitle">統計情報</div>
          <div class="ms-row-spread" id="sMainRow">
            <div class="ms-cell" id="sTotalCell"><div class="ms-lbl" id="sLblTotal">全国合計</div><div><span class="ms-val ms-val-lg" id="sTotal">-</span><span class="ms-unit" id="sUnitTotal">回</span></div></div>
            <div class="ms-cell" id="sAvgCell"><div class="ms-lbl" id="sLblAvg">全国平均</div><div><span class="ms-val ms-val-lg" id="sAvg">-</span><span class="ms-unit" id="sUnitAvg">回/10万人</span></div></div>
          </div>
          <div class="ms-div"></div>
          <div class="ms-row-spread">
            <div class="ms-cell"><div class="ms-lbl">最小</div><div class="ms-val" id="sMin">-</div><div class="ms-sub" id="sMinP"></div></div>
            <div class="ms-cell"><div class="ms-lbl">Q1</div><div class="ms-val" id="sQ1">-</div></div>
            <div class="ms-cell" style="text-align:center"><div class="ms-lbl">中央値</div><div class="ms-val" id="sMed">-</div></div>
            <div class="ms-cell"><div class="ms-lbl">Q3</div><div class="ms-val" id="sQ3">-</div></div>
            <div class="ms-cell" style="text-align:right"><div class="ms-lbl">最大</div><div class="ms-val" id="sMax">-</div><div class="ms-sub" id="sMaxP"></div></div>
          </div>
          <div class="ms-div"></div>
          <div class="ms-row">
            <div class="ms-cell"><div class="ms-lbl">ジニ係数</div><div class="ms-val" id="sGini">-</div></div>
            <div class="ms-cell"><div class="ms-lbl">変動係数</div><div class="ms-val" id="sCV">-</div></div>
          </div>
        </div>
        <div class="legend-ctrl" id="legendCtrl">
          <div class="lc-row">
            <span class="lc-lbl">Min</span>
            <input type="number" class="lc-input" id="scaleMin" min="0" step="100" value="0">
            <span class="lc-sep">–</span>
            <span class="lc-lbl">Max</span>
            <input type="number" class="lc-input" id="scaleMax" min="0" step="100" value="1000">
            <button class="lc-btn" onclick="applyManualScale()">適用</button>
            <button class="lc-btn" onclick="resetScale()">自動</button>
            <span class="lc-badge" id="scaleModeBadge">AUTO</span>
          </div>
        </div>
        <div class="tooltip" id="tooltip"></div>
        <div class="empty-st" id="empty" style="display:none"><div class="empty-st-text">左のパネルから算定項目を選択してください</div></div>
      </div>
      <div class="chart-container" id="chartContainer">
        <div class="chart-card">
          <div class="chart-title">年度別推移</div>
          <div class="chart-legend" id="chartLegend"></div>
          <svg id="chart-svg"></svg>
          <div class="chart-tooltip" id="chartTooltip"></div>
        </div>
      </div>
    </main>
  </div>
</div>

<script>
/* ================================================================ */
let DATA = null, GEO = null, animTimer = null, lcTimer = null;
const fmt = d3.format(',.0f'), fmtD = d3.format(',.1f'), fmtR = d3.format('.2f');

/* ================================================================ */
/* Analysis state                                                    */
/* ================================================================ */
const A = [
  { ids: new Set(), scaleDomain: null, scaleIsAuto: true },
  { ids: new Set(), scaleDomain: null, scaleIsAuto: true },
  { scaleDomain: null, scaleIsAuto: true }
];
let activeTab = 0;

/* Default IDs */
const DEFAULT_IDS_1 = new Set([
  '113001110','180018410','180018510','180019010','180019110','180019210','180019310','180031710',
  '180018910',
  '180019710','180026750','180035310',
  '180046610','180046710','180055010','180055110','180055210','180055310'
]);
const DEFAULT_IDS_2 = new Set([
  '180031710',
  '180018910',
  '180019710','180026750','180035310',
  '180046610','180046710','180055010','180055110','180055210','180055310'
]);

/* Color palettes */
const CSTOPS_BLUE   = ['#f0f9ff','#bae6fd','#38bdf8','#0284c7','#075985'];
const CSTOPS_GREEN  = ['#f0fdf4','#bbf7d0','#4ade80','#16a34a','#166534'];
const CSTOPS_ORANGE = ['#fff7ed','#fed7aa','#fb923c','#ea580c','#9a3412'];
const CLR_BLUE = '#0284c7', CLR_GREEN = '#16a34a', CLR_ORANGE = '#ea580c';

function getColorStops() {
  if (activeTab === 1) return CSTOPS_GREEN;
  if (activeTab === 2) return CSTOPS_ORANGE;
  return CSTOPS_BLUE;
}
function makeCS(dom, stops) {
  stops = stops || getColorStops();
  return d3.scaleLinear()
    .domain(d3.range(stops.length).map(i => dom[0] + i/(stops.length-1)*(dom[1]-dom[0])))
    .range(stops).interpolate(d3.interpolateRgb.gamma(2.2)).clamp(true);
}

/* ================================================================ */
/* Data reclassification                                            */
/* ================================================================ */
const RECLASS_MAP = { '180058750': { code: 'K154-4', name: '経頭蓋MRガイド下集束超音波治療' } };
function reclassifyData() {
  Object.entries(RECLASS_MAP).forEach(([procId, target]) => {
    let moved = null;
    for (const g of DATA.codes) {
      const idx = g.procedures.findIndex(p => p.id === procId);
      if (idx >= 0) { moved = g.procedures.splice(idx, 1)[0]; break; }
    }
    if (!moved) return;
    let tg = DATA.codes.find(g => g.code === target.code);
    if (!tg) {
      tg = { code: target.code, name: target.name, procedures: [] };
      const ins = DATA.codes.findIndex(g => g.code.localeCompare(target.code) > 0);
      if (ins >= 0) DATA.codes.splice(ins, 0, tg); else DATA.codes.push(tg);
    }
    tg.procedures.push(moved);
  });
}

/* ================================================================ */
/* Statistics helpers                                               */
/* ================================================================ */
function calcGini(sorted) {
  const n = sorted.length; if (n === 0) return 0;
  const mu = sorted.reduce((s,v) => s+v, 0) / n;
  if (mu === 0) return 0;
  let sum = 0;
  for (let i = 0; i < n; i++) sum += (2*(i+1) - n - 1) * sorted[i];
  return sum / (n * n * mu);
}
function calcCV(arr) {
  const n = arr.length; if (n === 0) return 0;
  const mu = arr.reduce((s,v) => s+v, 0) / n;
  if (mu === 0) return 0;
  const v = arr.reduce((s,x) => s + (x-mu)**2, 0) / n;
  return Math.sqrt(v) / mu;
}

/* ================================================================ */
/* Data helpers                                                     */
/* ================================================================ */
function getSelectedProcIds() {
  return [...document.querySelectorAll('.proc-cb:checked')].map(e => e.value);
}
function getYear() { return +document.getElementById('yearSlider').value; }

function calcPrefVals(year, procIds) {
  const r = {}, ys = String(year);
  Object.keys(DATA.prefectures).forEach(pc => {
    let tot = 0, hasNA = false, hasVal = false;
    const bd = {};
    procIds.forEach(id => {
      const raw = DATA.counts[id]?.[pc]?.[ys];
      if (raw === null) { bd[id] = null; hasNA = true; }
      else if (raw === undefined) { bd[id] = 0; }
      else { bd[id] = raw; tot += raw; hasVal = true; }
    });
    const pop = DATA.population[pc]?.[ys] ?? 0;
    const allNA = hasNA && !hasVal;
    r[pc] = { total: allNA ? null : tot, pop,
              per100k: allNA ? null : (pop > 0 ? tot/pop*1e5 : 0), bd, hasNA };
  });
  return r;
}

function calcRatioVals(year) {
  const ids1 = [...A[0].ids], ids2 = [...A[1].ids];
  const v1 = calcPrefVals(year, ids1), v2 = calcPrefVals(year, ids2);
  const r = {};
  Object.keys(DATA.prefectures).forEach(pc => {
    const a = v1[pc], b = v2[pc];
    const pop = a.pop;
    let ratio = null;
    /* ratio = 解析2 / 解析1 */
    if (a.total !== null && b.total !== null && a.total > 0) ratio = b.total / a.total;
    else if (a.total !== null && b.total !== null && a.total === 0 && b.total === 0) ratio = 0;
    r[pc] = { ratio, total1: a.total, total2: b.total, per100k1: a.per100k, per100k2: b.per100k, pop };
  });
  return r;
}

/* Lookup: procId → {classCode, className, procName, points} */
let PROC_LOOKUP = {};
function buildLookup() {
  DATA.codes.forEach(g => {
    g.procedures.forEach(p => {
      PROC_LOOKUP[p.id] = { classCode: g.code, className: g.name, procName: p.name, points: p.points };
    });
  });
}

/* ================================================================ */
/* Tab switching                                                     */
/* ================================================================ */
function saveCurrentState() {
  if (activeTab < 2) {
    A[activeTab].ids = new Set(getSelectedProcIds());
  }
}

function switchTab(tab) {
  if (tab === activeTab) return;
  saveCurrentState();
  activeTab = tab;
  /* Theme */
  const ct = document.getElementById('contentEl');
  ct.classList.remove('theme-green','theme-orange');
  if (tab === 1) ct.classList.add('theme-green');
  if (tab === 2) ct.classList.add('theme-orange');
  /* Tab buttons */
  document.querySelectorAll('.tab-btn').forEach(b => b.classList.toggle('active', +b.dataset.tab === tab));
  /* Panels */
  document.getElementById('procPanel').style.display = tab < 2 ? '' : 'none';
  document.getElementById('compPanel').style.display = tab === 2 ? '' : 'none';
  /* Empty state */
  document.getElementById('empty').style.display = 'none';
  if (tab < 2) {
    restoreCheckboxes(A[tab].ids);
    updateMap(true);
  } else {
    updateCompInfo();
    /* Delay to allow layout before chart renders */
    requestAnimationFrame(() => updateComparisonView());
  }
}

function restoreCheckboxes(ids) {
  document.querySelectorAll('.proc-cb').forEach(c => { c.checked = ids.has(c.value); });
  document.querySelectorAll('.class-cb').forEach(pcb => {
    const grp = pcb.closest('.class-group');
    const children = grp.querySelectorAll('.proc-cb');
    syncParent(pcb, children);
    const hasChecked = [...children].some(c => c.checked);
    grp.querySelector('.class-children').classList.toggle('open', hasChecked);
    grp.querySelector('.class-toggle').innerHTML = hasChecked ? '&#9660;' : '&#9654;';
  });
}

function updateCompInfo() {
  const getGroups = (ids) => {
    const groups = {};
    ids.forEach(id => {
      const info = PROC_LOOKUP[id];
      if (!info) return;
      if (!groups[info.classCode]) groups[info.classCode] = { name: info.className, count: 0 };
      groups[info.classCode].count++;
    });
    return Object.entries(groups).map(([c,g]) => `${c} ${g.name} (${g.count})`).join(', ');
  };
  document.getElementById('compInfo').innerHTML =
    `<div class="ci-section ci-blue"><div class="ci-label">解析1</div><div class="ci-count">${A[0].ids.size}項目選択</div><div class="ci-groups">${getGroups(A[0].ids)}</div></div>` +
    `<div class="ci-section ci-green"><div class="ci-label">解析2</div><div class="ci-count">${A[1].ids.size}項目選択</div><div class="ci-groups">${getGroups(A[1].ids)}</div></div>`;
}

/* ================================================================ */
/* Hierarchical checkbox UI                                         */
/* ================================================================ */
function buildProcList() {
  const el = document.getElementById('procList');
  el.innerHTML = '';
  DATA.codes.forEach(g => {
    const grp = document.createElement('div');
    grp.className = 'class-group';
    const hdr = document.createElement('div');
    hdr.className = 'class-header';
    hdr.innerHTML = `<span class="class-toggle">&#9654;</span>
      <input type="checkbox" class="class-cb" data-code="${g.code}">
      <span class="class-code">${g.code}</span>
      <span class="class-name" title="${g.name}">${g.name}</span>`;
    grp.appendChild(hdr);
    const ch = document.createElement('div');
    ch.className = 'class-children';
    g.procedures.forEach(p => {
      const item = document.createElement('label');
      item.className = 'proc-item';
      const pts = p.points != null ? `${fmt(p.points)}点` : '';
      item.innerHTML = `<input type="checkbox" class="proc-cb" value="${p.id}" data-parent="${g.code}">
        <span class="proc-name" title="${p.name}">${p.name}</span>
        <span class="proc-pts">${pts}</span>`;
      ch.appendChild(item);
    });
    grp.appendChild(ch);
    el.appendChild(grp);
    const toggle = hdr.querySelector('.class-toggle');
    const expandClick = () => {
      const open = ch.classList.toggle('open');
      toggle.innerHTML = open ? '&#9660;' : '&#9654;';
    };
    toggle.addEventListener('click', expandClick);
    hdr.querySelector('.class-code').addEventListener('click', expandClick);
    hdr.querySelector('.class-name').addEventListener('click', expandClick);
    const parentCb = hdr.querySelector('.class-cb');
    const childCbs = ch.querySelectorAll('.proc-cb');
    parentCb.addEventListener('change', () => {
      childCbs.forEach(c => c.checked = parentCb.checked);
      saveCurrentState();
      updateMap(true);
    });
    childCbs.forEach(c => c.addEventListener('change', () => {
      syncParent(parentCb, childCbs);
      saveCurrentState();
      updateMap(true);
    }));
  });
}
function syncParent(parentCb, childCbs) {
  const all = childCbs.length;
  const checked = [...childCbs].filter(c => c.checked).length;
  parentCb.checked = checked === all;
  parentCb.indeterminate = checked > 0 && checked < all;
}
function toggleAll(on) {
  document.querySelectorAll('.class-cb,.proc-cb').forEach(c => { c.checked = on; c.indeterminate = false; });
  saveCurrentState();
  updateMap(true);
}
function expandAll(open) {
  document.querySelectorAll('.class-children').forEach(c => c.classList.toggle('open', open));
  document.querySelectorAll('.class-toggle').forEach(t => t.innerHTML = open ? '&#9660;' : '&#9654;');
}

/* ================================================================ */
/* Map                                                              */
/* ================================================================ */
let prefPaths = {};

function getPrefCode(name) {
  return Object.entries(DATA.prefectures).find(([_,n]) => n === name)?.[0] ?? null;
}

let MGEO = null;
const MX = lon => lon * Math.PI / 180;
const MY = lat => Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360));

function toMercator(geo) {
  const out = JSON.parse(JSON.stringify(geo));
  out.features.forEach(f => {
    const g = f.geometry;
    const pj = pt => { pt[0] = MX(pt[0]); pt[1] = MY(pt[1]); };
    if (g.type === 'Polygon') g.coordinates.forEach(r => r.forEach(pj));
    else if (g.type === 'MultiPolygon') g.coordinates.forEach(p => p.forEach(r => r.forEach(pj)));
  });
  return out;
}

let statsPos = null;

function initMap() {
  const ct = document.getElementById('mapWrap');
  const svgEl = document.getElementById('map-svg');
  ct.classList.remove('scroll-mode');
  svgEl.style.height = '';
  /* Set map-wrap height relative to map-area viewport */
  const areaH = document.querySelector('.map-area').clientHeight;
  ct.style.height = Math.max(350, Math.round(areaH * 0.62)) + 'px';
  const W = ct.clientWidth, H = ct.clientHeight;
  if (W <= 0 || H <= 0) return;
  const svg = d3.select('#map-svg').attr('viewBox', `0 0 ${W} ${H}`);
  svg.selectAll('*').remove();
  prefPaths = {};

  svg.append('rect').attr('width', W).attr('height', H).attr('fill', 'white').attr('rx', 8);
  const mapH = H - 84;

  if (!MGEO) MGEO = toMercator(GEO);
  const mainF = MGEO.features.filter(f => f.properties.N03_001 !== '沖縄県');
  const okiF  = MGEO.features.filter(f => f.properties.N03_001 === '沖縄県');

  const lonL = 129, lonR = 146, latB = 30.5, latT = 46;
  const bbox = { type:'Feature', geometry:{ type:'Polygon', coordinates:[[
    [MX(lonL),MY(latB)],[MX(lonR),MY(latB)],[MX(lonR),MY(latT)],[MX(lonL),MY(latT)],[MX(lonL),MY(latB)]
  ]]}};
  const proj = d3.geoIdentity().reflectY(true).fitExtent([[20, 10], [W - 20, mapH - 10]], bbox);
  const path = d3.geoPath(proj);

  const defs = svg.append('defs');
  defs.append('clipPath').attr('id', 'mc').append('rect').attr('width', W).attr('height', mapH);

  const mg = svg.append('g').attr('clip-path', 'url(#mc)');
  mg.selectAll('path').data(mainF).join('path')
    .attr('d', path).attr('class', 'pref-path')
    .attr('data-pref', d => getPrefCode(d.properties.N03_001))
    .on('mouseenter', onHover).on('mousemove', onMove).on('mouseleave', onLeave)
    .each(function(d) { const pc = getPrefCode(d.properties.N03_001); if (pc) { if (!prefPaths[pc]) prefPaths[pc] = {}; prefPaths[pc].main = this; } });

  const okiFC = { type:'FeatureCollection', features: okiF };
  const ob = path.bounds(okiFC);
  const okiNW = ob[1][0] - ob[0][0], okiNH = ob[1][1] - ob[0][1];
  const iPd = 5;
  const bxW = okiNW + iPd * 2, bxH = okiNH + iPd * 2;
  const anchorPt = proj([MX(133), MY(39.5)]);
  const iX = (anchorPt ? anchorPt[0] : 65) - bxW / 2;
  const iY = (anchorPt ? anchorPt[1] : 14) - bxH / 2;
  const dx = iX + iPd - ob[0][0], dy = iY + iPd - ob[0][1];

  const ig = svg.append('g');
  ig.append('path')
    .attr('d', `M${iX + bxW},${iY} V${iY + bxH} H${iX}`)
    .attr('fill', 'none').attr('stroke', 'var(--border)').attr('stroke-width', 1).attr('stroke-dasharray', '3 2');

  const sAnchor = proj([MX(129.5), MY(45.5)]);
  const hokLeft = proj([MX(140), MY(43)]);
  const akitaTop = proj([MX(140), MY(40.2)]);
  const hokTop = proj([MX(140), MY(45.5)]);
  statsPos = sAnchor ? {
    baseX: sAnchor[0], baseY: sAnchor[1],
    hokLeftX: hokLeft ? hokLeft[0] : Infinity,
    akitaTopY: akitaTop ? akitaTop[1] : Infinity,
    hokTopY: hokTop ? hokTop[1] : 0
  } : null;

  const okig = ig.append('g').attr('transform', `translate(${dx},${dy})`);
  okig.selectAll('path').data(okiF).join('path')
    .attr('d', path).attr('class', 'pref-path')
    .attr('data-pref', d => getPrefCode(d.properties.N03_001))
    .on('mouseenter', onHover).on('mousemove', onMove).on('mouseleave', onLeave)
    .each(function(d) { const pc = getPrefCode(d.properties.N03_001); if (pc) { if (!prefPaths[pc]) prefPaths[pc] = {}; prefPaths[pc].inset = this; } });

  svg.append('g').attr('class', 'legend-g').attr('transform', `translate(${W / 2},${mapH + 10})`);
}

/* ================================================================ */
/* Update                                                           */
/* ================================================================ */
function computeAutoDomain(vals, key) {
  key = key || 'per100k';
  const v = Object.values(vals).map(v => v[key]).filter(v => v !== null && v > 0);
  return v.length ? [0, d3.quantile(v.sort(d3.ascending), .98) || 1] : [0, 1];
}
function updateScaleUI() {
  const st = A[activeTab];
  document.getElementById('scaleMin').value = Math.round(st.scaleDomain[0]);
  document.getElementById('scaleMax').value = Math.round(st.scaleDomain[1]);
  const b = document.getElementById('scaleModeBadge');
  b.textContent = st.scaleIsAuto ? 'AUTO' : '手動';
  b.style.background = st.scaleIsAuto ? 'var(--pri-lt)' : '#fef3c7';
  b.style.color = st.scaleIsAuto ? 'var(--pri)' : '#92400e';
}
function setupLegendCtrl() {
  const lc = document.getElementById('legendCtrl');
  lc.addEventListener('mouseenter', () => { clearTimeout(lcTimer); lc.classList.add('visible'); });
  lc.addEventListener('mouseleave', () => { lcTimer = setTimeout(() => lc.classList.remove('visible'), 400); });
}

function updateMap(recomputeScale = true) {
  if (activeTab === 2) { updateComparisonView(); return; }
  const ids = getSelectedProcIds(), yr = getYear();
  document.getElementById('empty').style.display = ids.length ? 'none' : 'flex';
  const vals = calcPrefVals(yr, ids);
  const st = A[activeTab];
  if (recomputeScale || !st.scaleDomain) {
    st.scaleDomain = computeAutoDomain(vals);
    st.scaleIsAuto = true;
    updateScaleUI();
  }
  const cs = makeCS(st.scaleDomain);
  d3.selectAll('.pref-path').each(function(){
    const pc = this.getAttribute('data-pref'), v = vals[pc];
    const c = (!v || !ids.length) ? '#f1f5f9'
             : v.per100k === null ? '#9ca3af'
             : v.per100k === 0 ? '#f1f5f9' : cs(v.per100k);
    d3.select(this).transition().duration(300).attr('fill', c);
  });
  updateLegend(cs, st.scaleDomain);
  updateStats(vals, ids);
  renderChart();
}

function updateComparisonView() {
  const yr = getYear();
  const rv = calcRatioVals(yr);
  const st = A[2];
  document.getElementById('empty').style.display = 'none';
  if (!st.scaleDomain || st.scaleIsAuto) {
    st.scaleDomain = computeAutoDomain(rv, 'ratio');
    st.scaleIsAuto = true;
    updateScaleUI();
  }
  const cs = makeCS(st.scaleDomain, CSTOPS_ORANGE);
  d3.selectAll('.pref-path').each(function(){
    const pc = this.getAttribute('data-pref'), v = rv[pc];
    const c = (!v || v.ratio === null) ? '#9ca3af'
             : v.ratio === 0 ? '#f1f5f9' : cs(v.ratio);
    d3.select(this).transition().duration(300).attr('fill', c);
  });
  updateLegend(cs, st.scaleDomain, true);
  updateCompStats(rv);
  renderChart();
}

function applyManualScale() {
  const lo = parseFloat(document.getElementById('scaleMin').value) || 0;
  const hi = parseFloat(document.getElementById('scaleMax').value) || 1;
  const st = A[activeTab];
  st.scaleDomain = [lo, Math.max(lo + (activeTab === 2 ? 0.1 : 1), hi)];
  st.scaleIsAuto = false;
  updateScaleUI();
  if (activeTab === 2) updateComparisonView(); else updateMap(false);
}
function resetScale() {
  const st = A[activeTab];
  st.scaleDomain = null;
  st.scaleIsAuto = true;
  if (activeTab === 2) updateComparisonView(); else updateMap(true);
}

function updateLegend(cs, dom, isRatio) {
  const svg = d3.select('#map-svg'), vb = svg.attr('viewBox')?.split(' ').map(Number);
  if (!vb) return;
  const W = vb[2];
  const g = svg.select('.legend-g'); g.selectAll('*').remove();
  if(dom[1]<=0) return;
  const bW = Math.min(280, W*.4), bH = 12;
  g.append('rect').attr('x',-bW/2-10).attr('y',-24).attr('width',bW+100).attr('height',bH+48)
    .attr('fill','transparent').attr('pointer-events','all');
  const defs = svg.select('defs');
  defs.selectAll('#lg').remove();
  const grad = defs.append('linearGradient').attr('id','lg').attr('x1','0%').attr('x2','100%');
  for(let i=0;i<=20;i++){const t=i/20; grad.append('stop').attr('offset',`${t*100}%`).attr('stop-color',cs(dom[0]+t*(dom[1]-dom[0])));}
  g.append('rect').attr('x',-bW/2).attr('width',bW).attr('height',bH).attr('rx',3).style('fill','url(#lg)');
  const sc = d3.scaleLinear().domain(dom).range([-bW/2,bW/2]);
  const tickFmt = isRatio ? d3.format('.1f') : fmt;
  g.append('g').attr('class','legend-axis').attr('transform',`translate(0,${bH})`).call(d3.axisBottom(sc).ticks(5).tickFormat(tickFmt).tickSize(4));
  g.append('text').attr('class','legend-title').attr('y',-7).attr('text-anchor','middle')
    .text(isRatio ? '解析2 / 解析1 比' : '人口10万人あたり算定回数');
  /* NA indicator */
  const naX = bW/2 + 20;
  const naG = g.append('g').attr('pointer-events','all');
  naG.append('rect').attr('x', naX).attr('width', 14).attr('height', bH).attr('rx', 2).attr('fill', '#9ca3af');
  naG.append('text').attr('x', naX + 20).attr('y', bH - 1).style('font-size','14px').attr('fill','var(--text-ll)').text('データなし');
  naG.on('mouseenter', function(ev) {
    const tip = document.getElementById('tooltip');
    tip.innerHTML = '<div class="tt-pref">データなし</div><div style="font-size:11.5px;color:var(--text-l)">値の欠損、または10未満の値が<br>プライバシー保護のためマスクされています</div>';
    tip.classList.add('visible');
    positionTipFromEvent(ev);
  }).on('mousemove', function(ev) { positionTipFromEvent(ev); })
    .on('mouseleave', function() { document.getElementById('tooltip').classList.remove('visible'); });
  const lc = document.getElementById('legendCtrl');
  g.style('cursor','pointer')
    .on('mouseenter', () => { clearTimeout(lcTimer); lc.classList.add('visible'); })
    .on('mouseleave', () => { lcTimer = setTimeout(() => lc.classList.remove('visible'), 400); });
}

function positionTipFromEvent(ev) {
  const tip = document.getElementById('tooltip'), r = document.getElementById('mapWrap').getBoundingClientRect();
  let x = ev.clientX - r.left + 14, y = ev.clientY - r.top - 8;
  const tr = tip.getBoundingClientRect();
  if (x + tr.width > r.width - 8) x = ev.clientX - r.left - tr.width - 14;
  if (y + tr.height > r.height - 8) y = r.height - tr.height - 8;
  if (y < 8) y = 8;
  tip.style.left = x + 'px'; tip.style.top = y + 'px';
}

function positionStats() {
  const ms = document.getElementById('mapStats');
  const mapWrap = document.getElementById('mapWrap');
  const svgEl = document.getElementById('map-svg');
  if (!statsPos || ms.style.display === 'none') {
    mapWrap.classList.remove('scroll-mode');
    svgEl.style.height = '';
    return;
  }
  const pad = 12;
  const msW = ms.offsetWidth;
  const statsR = statsPos.baseX + msW;
  if (statsR > statsPos.hokLeftX) {
    if (!mapWrap.classList.contains('scroll-mode')) {
      mapWrap.classList.add('scroll-mode');
      const vb = svgEl.getAttribute('viewBox')?.split(' ').map(Number);
      if (vb) svgEl.style.height = vb[3] + 'px';
      mapWrap.style.height = 'auto';
    }
    ms.style.left = '';
    ms.style.top = '';
  } else {
    if (mapWrap.classList.contains('scroll-mode')) {
      mapWrap.classList.remove('scroll-mode');
      svgEl.style.height = '';
      const aH = document.querySelector('.map-area').clientHeight;
      mapWrap.style.height = Math.max(350, Math.round(aH * 0.62)) + 'px';
    }
    ms.style.left = Math.round(statsPos.baseX + pad) + 'px';
    ms.style.top = Math.round(statsPos.baseY + pad) + 'px';
    const msH = ms.offsetHeight;
    const statsB = statsPos.baseY + msH;
    if (statsB > statsPos.akitaTopY) {
      const newTop = Math.max(4, statsPos.hokTopY + pad - msH - 8);
      ms.style.top = newTop + 'px';
    }
  }
}

function updateStats(vals, ids) {
  const panel = document.getElementById('mapStats');
  const n = ids.length > 0;
  panel.style.display = n ? '' : 'none';
  if (!n) return;
  document.getElementById('sTitle').textContent = '統計情報';
  document.getElementById('sLblTotal').textContent = '全国合計';
  document.getElementById('sUnitTotal').textContent = '回';
  document.getElementById('sLblAvg').textContent = '全国平均';
  document.getElementById('sUnitAvg').textContent = '回/10万人';
  document.getElementById('sAvgCell').style.display = '';
  const es = Object.entries(vals);
  const valid = es.filter(([_,v]) => v.total !== null);
  const totC = valid.reduce((s,[_,v])=>s+v.total,0);
  const totP = valid.reduce((s,[_,v])=>s+v.pop,0);
  const avg = totP>0 ? totC/totP*1e5 : 0;
  let maxV=0,minV=Infinity,maxPr='-',minPr='-';
  valid.forEach(([pc,v])=>{ if(v.per100k>maxV){maxV=v.per100k;maxPr=DATA.prefectures[pc]} if(v.per100k>0&&v.per100k<minV){minV=v.per100k;minPr=DATA.prefectures[pc]} });
  const sorted = valid.map(([_,v])=>v.per100k).filter(v=>v!==null).sort(d3.ascending);
  const q1 = d3.quantile(sorted,.25)||0, med = d3.quantile(sorted,.5)||0;
  const q3 = d3.quantile(sorted,.75)||0;
  const gini = calcGini(sorted), cv = calcCV(sorted);
  document.getElementById('sAvg').textContent = fmt(avg);
  document.getElementById('sTotal').textContent = fmt(totC);
  document.getElementById('sMax').textContent = fmt(maxV);
  document.getElementById('sMaxP').textContent = maxPr;
  document.getElementById('sMin').textContent = minV<Infinity ? fmt(minV) : '-';
  document.getElementById('sMinP').textContent = minV<Infinity ? minPr : '';
  document.getElementById('sQ1').textContent = fmt(q1);
  document.getElementById('sMed').textContent = fmt(med);
  document.getElementById('sQ3').textContent = fmt(q3);
  document.getElementById('sGini').textContent = gini.toFixed(3);
  document.getElementById('sCV').textContent = cv.toFixed(3);
  positionStats();
}

function updateCompStats(rv) {
  const panel = document.getElementById('mapStats');
  panel.style.display = '';
  document.getElementById('sTitle').textContent = '比較統計 (解析2÷解析1)';
  document.getElementById('sLblTotal').textContent = '全国比';
  document.getElementById('sUnitTotal').textContent = '';
  document.getElementById('sAvgCell').style.display = 'none';
  const es = Object.entries(rv);
  const valid = es.filter(([_,v]) => v.ratio !== null && v.ratio > 0);
  /* National ratio */
  const tot1 = es.reduce((s,[_,v]) => s + (v.total1 ?? 0), 0);
  const tot2 = es.reduce((s,[_,v]) => s + (v.total2 ?? 0), 0);
  const natRatio = tot1 > 0 ? tot2/tot1 : 0;
  document.getElementById('sTotal').textContent = fmtR(natRatio);
  document.getElementById('sAvg').textContent = '';
  let maxV=0,minV=Infinity,maxPr='-',minPr='-';
  valid.forEach(([pc,v])=>{ if(v.ratio>maxV){maxV=v.ratio;maxPr=DATA.prefectures[pc]} if(v.ratio<minV){minV=v.ratio;minPr=DATA.prefectures[pc]} });
  const sorted = valid.map(([_,v])=>v.ratio).sort(d3.ascending);
  const q1 = d3.quantile(sorted,.25)||0, med = d3.quantile(sorted,.5)||0;
  const q3 = d3.quantile(sorted,.75)||0;
  const gini = calcGini(sorted), cv = calcCV(sorted);
  document.getElementById('sMax').textContent = maxV>0 ? fmtR(maxV) : '-';
  document.getElementById('sMaxP').textContent = maxPr;
  document.getElementById('sMin').textContent = minV<Infinity ? fmtR(minV) : '-';
  document.getElementById('sMinP').textContent = minV<Infinity ? minPr : '';
  document.getElementById('sQ1').textContent = fmtR(q1);
  document.getElementById('sMed').textContent = fmtR(med);
  document.getElementById('sQ3').textContent = fmtR(q3);
  document.getElementById('sGini').textContent = gini.toFixed(3);
  document.getElementById('sCV').textContent = cv.toFixed(3);
  positionStats();
}

/* ================================================================ */
/* Tooltip                                                          */
/* ================================================================ */
function onHover(ev, d) {
  d3.selectAll('.pref-path.hovered').classed('hovered', false);
  d3.select(this).raise().classed('hovered', true);
  const pc = this.getAttribute('data-pref');
  const yr = getYear();
  let h = `<div class="tt-pref">${DATA.prefectures[pc]}</div>`;
  if (activeTab === 2) {
    const rv = calcRatioVals(yr);
    const v = rv[pc];
    if (v) {
      h += `<div class="tt-row"><span class="tt-lbl" style="color:${CLR_BLUE}">解析1 合計</span><span class="tt-val">${v.total1===null?'-':fmt(v.total1)}</span></div>`;
      h += `<div class="tt-row"><span class="tt-lbl" style="color:${CLR_BLUE}">10万人あたり</span><span class="tt-val">${v.per100k1===null?'-':fmtD(v.per100k1)}</span></div>`;
      h += `<div class="tt-div"></div>`;
      h += `<div class="tt-row"><span class="tt-lbl" style="color:${CLR_GREEN}">解析2 合計</span><span class="tt-val">${v.total2===null?'-':fmt(v.total2)}</span></div>`;
      h += `<div class="tt-row"><span class="tt-lbl" style="color:${CLR_GREEN}">10万人あたり</span><span class="tt-val">${v.per100k2===null?'-':fmtD(v.per100k2)}</span></div>`;
      h += `<div class="tt-div"></div>`;
      h += `<div class="tt-row"><span class="tt-lbl" style="color:${CLR_ORANGE};font-weight:700">比 (解析2÷解析1)</span><span class="tt-val tt-hi" style="color:${CLR_ORANGE}">${v.ratio===null?'-':fmtR(v.ratio)}</span></div>`;
    }
  } else {
    const ids = getSelectedProcIds(), vals = calcPrefVals(yr, ids), v = vals[pc];
    if (ids.length && v) {
      const groups = {};
      ids.forEach(id => {
        const info = PROC_LOOKUP[id];
        if (!info) return;
        if (!groups[info.classCode]) groups[info.classCode] = { name: info.className, items: [] };
        groups[info.classCode].items.push({ id, name: info.procName, count: v.bd[id] });
      });
      Object.entries(groups).forEach(([cc, g]) => {
        if (ids.length > 3) {
          const na = g.items.some(i => i.count === null);
          const sum = g.items.reduce((s,i) => s + (i.count ?? 0), 0);
          h += `<div class="tt-row"><span class="tt-lbl">${cc} ${g.name}</span><span class="tt-val">${na && sum===0 ? '-' : fmt(sum)}</span></div>`;
        } else {
          g.items.forEach(i => {
            h += `<div class="tt-row"><span class="tt-lbl">${i.name}</span><span class="tt-val">${i.count===null ? '-' : fmt(i.count)}</span></div>`;
          });
        }
      });
      if (ids.length > 1) { h += `<div class="tt-div"></div><div class="tt-row"><span class="tt-lbl">合計</span><span class="tt-val">${v.total===null ? '-' : fmt(v.total)}</span></div>`; }
      h += `<div class="tt-div"></div>`;
      h += `<div class="tt-row"><span class="tt-lbl">人口</span><span class="tt-val">${fmt(v.pop)}</span></div>`;
      h += `<div class="tt-row"><span class="tt-lbl">10万人あたり</span><span class="tt-val tt-hi">${v.per100k===null ? '-' : fmtD(v.per100k)}</span></div>`;
    }
  }
  const tip = document.getElementById('tooltip');
  tip.innerHTML = h; tip.classList.add('visible');
}
function onMove(ev) {
  positionTipFromEvent(ev);
}
function onLeave() {
  d3.select(this).classed('hovered', false);
  document.getElementById('tooltip').classList.remove('visible');
}

/* ================================================================ */
/* Time series chart                                                */
/* ================================================================ */
let lastChartLines = [];

function computeChartData() {
  const years = DATA.years;
  const ids1 = [...A[0].ids], ids2 = [...A[1].ids];
  const per100k1 = [], per100k2 = [], ratio = [];
  const gini1 = [], gini2 = [], giniRatio = [];
  years.forEach(yr => {
    const v1 = calcPrefVals(yr, ids1), v2 = calcPrefVals(yr, ids2);
    const natPer100k = (vals) => {
      const valid = Object.values(vals).filter(v => v.total !== null);
      const totC = valid.reduce((s,v) => s + v.total, 0);
      const totP = valid.reduce((s,v) => s + v.pop, 0);
      return totP > 0 ? totC/totP*1e5 : 0;
    };
    const giniOf = (vals) => {
      const sorted = Object.values(vals).map(v => v.per100k).filter(v => v !== null).sort(d3.ascending);
      return calcGini(sorted);
    };
    const n1 = natPer100k(v1), n2 = natPer100k(v2);
    per100k1.push(n1); per100k2.push(n2);
    ratio.push(n1 > 0 ? n2/n1 : null);
    gini1.push(giniOf(v1)); gini2.push(giniOf(v2));
    const ratioArr = [];
    Object.keys(DATA.prefectures).forEach(pc => {
      const a = v1[pc], b = v2[pc];
      if (a.total !== null && b.total !== null && a.total > 0) ratioArr.push(b.total / a.total);
    });
    giniRatio.push(calcGini(ratioArr.sort(d3.ascending)));
  });
  if (activeTab === 0) return {
    years,
    leftLines: [{ label: '全国値(解析1)', data: per100k1, color: CLR_BLUE, dash: false, fmt: v => fmtD(v) + ' /10万人' }],
    rightLines: [{ label: 'Gini(解析1)', data: gini1, color: CLR_BLUE, dash: true, fmt: v => v.toFixed(3) }]
  };
  if (activeTab === 1) return {
    years,
    leftLines: [{ label: '全国値(解析2)', data: per100k2, color: CLR_GREEN, dash: false, fmt: v => fmtD(v) + ' /10万人' }],
    rightLines: [{ label: 'Gini(解析2)', data: gini2, color: CLR_GREEN, dash: true, fmt: v => v.toFixed(3) }]
  };
  return {
    years,
    leftLines: [
      { label: '全国値(解析1)', data: per100k1, color: CLR_BLUE, dash: false, fmt: v => fmtD(v) + ' /10万人' },
      { label: '全国値(解析2)', data: per100k2, color: CLR_GREEN, dash: false, fmt: v => fmtD(v) + ' /10万人' },
    ],
    rightLines: [
      { label: '比 (解析2÷解析1)', data: ratio, color: CLR_ORANGE, dash: false, fmt: v => fmtR(v) },
      { label: 'Gini(解析1)', data: gini1, color: CLR_BLUE, dash: true, fmt: v => v.toFixed(3) },
      { label: 'Gini(解析2)', data: gini2, color: CLR_GREEN, dash: true, fmt: v => v.toFixed(3) },
      { label: 'Gini(比)', data: giniRatio, color: CLR_ORANGE, dash: true, fmt: v => v.toFixed(3) },
    ]
  };
}

function renderChart() {
  const container = document.getElementById('chartContainer');
  const card = container.querySelector('.chart-card');
  const W = card.clientWidth - 28;
  if (W <= 0) { requestAnimationFrame(renderChart); return; }
  const H = 260;
  const m = { top: 14, right: 52, bottom: 30, left: 52 };

  const data = computeChartData();
  const { years, leftLines, rightLines } = data;
  lastChartLines = [...leftLines, ...rightLines];

  /* Legend */
  const leg = document.getElementById('chartLegend');
  leg.innerHTML = lastChartLines.map(l =>
    `<div class="chart-legend-item"><div class="chart-legend-line ${l.dash?'dashed':''}" style="background:${l.dash?'none':l.color};color:${l.color}"></div>${l.label}</div>`
  ).join('');
  leg.querySelectorAll('.chart-legend-line.dashed').forEach(el => {
    const c = el.style.color;
    el.style.background = `repeating-linear-gradient(90deg,${c} 0 5px,transparent 5px 8px)`;
    el.style.height = '2px';
  });

  const svg = d3.select('#chart-svg').attr('viewBox', `0 0 ${W} ${H}`);
  svg.selectAll('*').remove();
  const iW = W - m.left - m.right, iH = H - m.top - m.bottom;
  const xScale = d3.scaleLinear().domain([years[0], years[years.length-1]]).range([m.left, W - m.right]);

  /* Y scales: 0 → max * 1.1 */
  const leftMax = d3.max(leftLines.flatMap(l => l.data.filter(v => v !== null))) || 1;
  const rightMax = d3.max(rightLines.flatMap(l => l.data.filter(v => v !== null))) || 1;
  const yLeft = d3.scaleLinear().domain([0, leftMax * 1.1]).range([H - m.bottom, m.top]);
  const yRight = d3.scaleLinear().domain([0, rightMax * 1.1]).range([H - m.bottom, m.top]);

  /* Grid */
  svg.append('g').selectAll('line').data(d3.range(6).map(i => yLeft.domain()[0]+i/5*(yLeft.domain()[1]-yLeft.domain()[0]))).join('line')
    .attr('x1', m.left).attr('x2', W - m.right)
    .attr('y1', d => yLeft(d)).attr('y2', d => yLeft(d))
    .attr('stroke', '#f1f5f9').attr('stroke-width', 0.5);

  /* X axis */
  svg.append('g').attr('transform', `translate(0,${H - m.bottom})`)
    .call(d3.axisBottom(xScale).tickValues(years).tickFormat(d3.format('d')).tickSize(4))
    .selectAll('text').style('font-size', '11px').attr('fill', 'var(--text-ll)');

  /* Left Y axis */
  const la = svg.append('g').attr('transform', `translate(${m.left},0)`)
    .call(d3.axisLeft(yLeft).ticks(5).tickFormat(d3.format(',.0f')).tickSize(0));
  la.selectAll('text').style('font-size', '10px').attr('fill', 'var(--text-l)');
  la.select('.domain').attr('stroke', 'var(--border)');
  svg.append('text').attr('transform','rotate(-90)').attr('x',-(m.top+iH/2)).attr('y',12)
    .attr('text-anchor','middle').style('font-size','10px').attr('fill','var(--text-ll)').text('回/10万人');

  /* Right Y axis */
  const ra = svg.append('g').attr('transform', `translate(${W - m.right},0)`)
    .call(d3.axisRight(yRight).ticks(5).tickFormat(d3.format('.3f')).tickSize(0));
  ra.selectAll('text').style('font-size', '10px').attr('fill', 'var(--text-l)');
  ra.select('.domain').attr('stroke', 'var(--border)');
  svg.append('text').attr('transform','rotate(90)').attr('x',m.top+iH/2).attr('y',-(W-12))
    .attr('text-anchor','middle').style('font-size','10px').attr('fill','var(--text-ll)')
    .text(activeTab === 2 ? 'Gini / 比' : 'Gini');

  svg.selectAll('.domain').attr('stroke', 'var(--border)');

  /* Lines */
  const lineL = d3.line().defined(d => d[1] !== null).x(d => xScale(d[0])).y(d => yLeft(d[1]));
  const lineR = d3.line().defined(d => d[1] !== null).x(d => xScale(d[0])).y(d => yRight(d[1]));
  leftLines.forEach(l => {
    svg.append('path').datum(years.map((yr,i) => [yr, l.data[i]])).attr('d', lineL)
      .attr('fill','none').attr('stroke',l.color).attr('stroke-width',2)
      .attr('stroke-dasharray',l.dash?'6 3':'none').attr('opacity',0.85);
  });
  rightLines.forEach(l => {
    svg.append('path').datum(years.map((yr,i) => [yr, l.data[i]])).attr('d', lineR)
      .attr('fill','none').attr('stroke',l.color).attr('stroke-width',2)
      .attr('stroke-dasharray',l.dash?'6 3':'none').attr('opacity',0.85);
  });

  /* Current year marker */
  const curYear = getYear();
  svg.append('line')
    .attr('x1', xScale(curYear)).attr('x2', xScale(curYear))
    .attr('y1', m.top).attr('y2', H - m.bottom)
    .attr('stroke', 'var(--text-ll)').attr('stroke-width', 1.5).attr('stroke-dasharray', '4 3');

  /* Hover */
  const hoverG = svg.append('g').style('display', 'none');
  hoverG.append('line').attr('y1', m.top).attr('y2', H - m.bottom)
    .attr('stroke', '#64748b').attr('stroke-width', 1).attr('stroke-dasharray', '3 2');
  const allLines = lastChartLines;
  const nLeft = leftLines.length;
  const dotsArr = allLines.map(l => hoverG.append('circle').attr('r', 4)
    .attr('fill', l.color).attr('stroke', 'white').attr('stroke-width', 1.5));

  svg.append('rect').attr('x', m.left).attr('y', m.top)
    .attr('width', iW).attr('height', iH)
    .attr('fill', 'transparent').attr('pointer-events', 'all')
    .on('mousemove', function(ev) {
      const [mx] = d3.pointer(ev);
      let closest = 0, minDist = Infinity;
      years.forEach((yr, i) => { const d = Math.abs(xScale(yr) - mx); if (d < minDist) { minDist = d; closest = i; } });
      const yr = years[closest];
      hoverG.style('display', null);
      hoverG.select('line').attr('x1', xScale(yr)).attr('x2', xScale(yr));
      allLines.forEach((l, li) => {
        const v = l.data[closest];
        const yS = li < nLeft ? yLeft : yRight;
        dotsArr[li].attr('cx', xScale(yr)).attr('cy', v !== null ? yS(v) : -100)
          .style('display', v !== null ? null : 'none');
      });
      showChartTooltip(ev, yr, closest);
    })
    .on('mouseleave', function() {
      hoverG.style('display', 'none');
      document.getElementById('chartTooltip').classList.remove('visible');
    });
}

function showChartTooltip(ev, yr, idx) {
  const tip = document.getElementById('chartTooltip');
  let h = `<div class="ct-year">${yr}年度</div>`;
  lastChartLines.forEach(l => {
    const v = l.data[idx];
    h += `<div class="ct-row"><span class="ct-dot" style="background:${l.color}"></span><span class="ct-lbl">${l.label}</span><span class="ct-val">${v !== null ? l.fmt(v) : '-'}</span></div>`;
  });
  tip.innerHTML = h;
  tip.classList.add('visible');
  const card = tip.closest('.chart-card');
  const cr = card.getBoundingClientRect();
  let x = ev.clientX - cr.left + 14, y = ev.clientY - cr.top - 8;
  const tr = tip.getBoundingClientRect();
  if (x + tr.width > cr.width - 8) x = ev.clientX - cr.left - tr.width - 14;
  if (y + tr.height > cr.height - 8) y = cr.height - tr.height - 8;
  if (y < 8) y = 8;
  tip.style.left = x + 'px'; tip.style.top = y + 'px';
}

/* ================================================================ */
/* Controls                                                         */
/* ================================================================ */
function setupControls() {
  buildProcList();
  A[0].ids = new Set(DEFAULT_IDS_1);
  A[1].ids = new Set(DEFAULT_IDS_2);
  restoreCheckboxes(A[0].ids);

  const sl = document.getElementById('yearSlider');
  sl.addEventListener('input', () => { document.getElementById('yearDisp').innerHTML = sl.value+'<span>年度</span>'; updateMap(false); });
  const tEl = document.getElementById('yearTicks');
  DATA.years.forEach(y => { const s=document.createElement('span'); s.textContent = y%2===0?y:''; tEl.appendChild(s); });
}

/* ================================================================ */
/* Animation                                                        */
/* ================================================================ */
function toggleAnim() { animTimer ? stopAnim() : startAnim(); }
function startAnim() {
  const btn=document.getElementById('playBtn'); btn.innerHTML='&#9632; 停止'; btn.classList.add('active');
  const sp = +document.getElementById('speedSel').value, sl = document.getElementById('yearSlider');
  animTimer = setInterval(()=>{ let y=+sl.value; y = y>=2023?2014:y+1; sl.value=y; document.getElementById('yearDisp').innerHTML=y+'<span>年度</span>'; updateMap(false); }, sp);
}
function stopAnim() { clearInterval(animTimer); animTimer=null; const b=document.getElementById('playBtn'); b.innerHTML='&#9654; 再生'; b.classList.remove('active'); }
document.getElementById('speedSel').addEventListener('change', () => { if (animTimer) { stopAnim(); startAnim(); } });

/* ================================================================ */
/* CSV                                                              */
/* ================================================================ */
function downloadCSV(allYears) {
  const years = allYears ? DATA.years : [getYear()];
  const prefs = Object.keys(DATA.prefectures).sort();
  let csv, fname;
  if (activeTab === 2) {
    csv = '\uFEFF都道府県コード,都道府県名,年度,解析1合計,解析2合計,解析1_10万人あたり,解析2_10万人あたり,比(解析2÷解析1)\n';
    years.forEach(yr => {
      const rv = calcRatioVals(yr);
      prefs.forEach(pc => {
        const v = rv[pc];
        csv += `${pc},${DATA.prefectures[pc]},${yr},${v.total1===null?'-':v.total1},${v.total2===null?'-':v.total2},${v.per100k1===null?'-':v.per100k1.toFixed(1)},${v.per100k2===null?'-':v.per100k2.toFixed(1)},${v.ratio===null?'-':v.ratio.toFixed(4)}\n`;
      });
    });
    fname = allYears ? 'ndb_comparison_all.csv' : `ndb_comparison_${years[0]}.csv`;
  } else {
    const ids = [...A[activeTab].ids];
    csv = '\uFEFF都道府県コード,都道府県名,年度,合計算定回数,人口,人口10万人あたり\n';
    years.forEach(yr => {
      const vals = calcPrefVals(yr, ids);
      prefs.forEach(pc => {
        const v = vals[pc];
        csv += `${pc},${DATA.prefectures[pc]},${yr},${v.total===null?'-':v.total},${v.pop},${v.per100k===null?'-':(v.pop>0?v.per100k.toFixed(1):'')}\n`;
      });
    });
    fname = allYears ? `ndb_radiation_a${activeTab+1}_all.csv` : `ndb_radiation_a${activeTab+1}_${years[0]}.csv`;
  }
  const a = document.createElement('a');
  a.href = URL.createObjectURL(new Blob([csv],{type:'text/csv;charset=utf-8;'}));
  a.download = fname;
  document.body.appendChild(a); a.click(); document.body.removeChild(a);
}

/* ================================================================ */
/* Sidebar toggle                                                   */
/* ================================================================ */
function toggleSidebar() {
  const sb = document.querySelector('.sidebar');
  const rh = document.getElementById('resizeHandle');
  const btn = document.getElementById('sidebarToggle');
  const collapsed = sb.classList.toggle('collapsed');
  rh.style.display = collapsed ? 'none' : '';
  btn.classList.toggle('active', !collapsed);
  clearTimeout(resizeT);
  resizeT = setTimeout(() => { initMap(); updateMap(false); }, 280);
}

/* ================================================================ */
/* Resize                                                           */
/* ================================================================ */
let resizeT;
window.addEventListener('resize', () => { clearTimeout(resizeT); resizeT = setTimeout(()=>{ initMap(); updateMap(false); }, 200); });

function setupResize() {
  const handle = document.getElementById('resizeHandle');
  const sidebar = document.querySelector('.sidebar');
  let startX, startW;
  handle.addEventListener('mousedown', e => {
    startX = e.clientX; startW = sidebar.offsetWidth;
    handle.classList.add('dragging');
    document.body.style.cursor = 'col-resize';
    document.body.style.userSelect = 'none';
    document.addEventListener('mousemove', onDrag);
    document.addEventListener('mouseup', onDragEnd);
    e.preventDefault();
  });
  function onDrag(e) {
    const newW = Math.max(220, Math.min(700, startW + e.clientX - startX));
    sidebar.style.width = newW + 'px';
  }
  function onDragEnd() {
    handle.classList.remove('dragging');
    document.body.style.cursor = '';
    document.body.style.userSelect = '';
    document.removeEventListener('mousemove', onDrag);
    document.removeEventListener('mouseup', onDragEnd);
    clearTimeout(resizeT);
    resizeT = setTimeout(() => { initMap(); updateMap(false); }, 150);
  }
}

/* ================================================================ */
/* Init                                                             */
/* ================================================================ */
async function init() {
  try {
    const [gr, dr] = await Promise.all([fetch('data/prefectures.geojson'), fetch('data/ndb_radiation.json')]);
    GEO = await gr.json(); DATA = await dr.json();
    reclassifyData(); buildLookup(); setupControls(); setupResize(); setupLegendCtrl();
    initMap(); updateMap(true);
    document.getElementById('loading').classList.add('hidden');
  } catch(e) {
    document.querySelector('.load-text').textContent = 'データ読み込み失敗。python3 -m http.server でサーブしてください。';
    console.error(e);
  }
}
init();
</script>
</body>
</html>
